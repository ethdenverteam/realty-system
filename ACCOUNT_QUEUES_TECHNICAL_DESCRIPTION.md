# Техническое описание очередей аккаунтной автопубликации

## Назначение подсистемы

Подсистема очередей аккаунтов отвечает за публикацию объектов в Telegram от имени пользовательских аккаунтов, а не от имени бота.  
Ее задачи:

- хранить отложенные и текущие задачи публикации;
- распределять публикации по времени в зависимости от режима аккаунта;
- учитывать дневные лимиты, дубликаты и ограничения Telegram;
- обеспечивать восстановление после таймаутов и аварийных ситуаций.

## Главные сущности и данные

### Конфигурация автопубликации объекта

Для каждого объекта используется конфигурация автопубликации, в которой хранятся:

- включенность автопубликации;
- включенность публикации через аккаунты;
- список аккаунтов для объекта;
- список чатов для каждого аккаунта;
- формат публикации.

Ключевой блок данных — конфигурация аккаунтов (структура со списком аккаунтов и чатов).

### Очередь аккаунтных публикаций

Отдельная таблица хранит каждую задачу публикации через аккаунт:

- объект;
- чат;
- аккаунт;
- пользователь;
- статус задачи;
- время плановой публикации;
- время старта и завершения;
- число попыток;
- текст последней ошибки;
- идентификатор сообщения.

### Аккаунт Telegram

У аккаунта используются:

- режим скорости публикации;
- дневной лимит;
- активность аккаунта;
- последняя ошибка;
- время последнего успешного использования;
- фиксированный интервал (если выбран режим фиксированного интервала).

### История публикаций

История нужна для:

- проверки дневных лимитов;
- анализа факта публикации;
- контроля дубликатов.

## Статусы очереди и жизненный цикл

Обычный поток задачи:

- `pending` — задача создана и ожидает;
- `processing` — задача взята воркером в работу;
- `completed` — публикация успешна;
- `failed` — публикация завершилась ошибкой;
- `flood_wait` — получено ограничение Telegram по ожиданию.

Переходы:

- `pending -> processing` при взятии задачи в обработку;
- `processing -> completed` при успешной отправке;
- `processing -> pending` при временной ошибке (повтор позже);
- `processing -> failed` при фатальной ошибке или исчерпании попыток;
- `processing -> flood_wait` при блокировке Telegram.

## Создание задач

### Ежедневная генерация

Ежедневный планировщик формирует задачи для включенных объектов и валидных аккаунтных конфигураций.  
Создание идет в два потока:

- бот-очереди;
- аккаунтные очереди.

Для аккаунтных задач:

- берется список объектов с включенной автопубликацией;
- читается список аккаунтов и чатов из конфигурации;
- проверяется активность аккаунта;
- проверяется принадлежность чатов аккаунту (учитываются старая и новая схемы связей);
- задачи группируются по аккаунтам;
- время задач рассчитывается с учетом режима и лимита аккаунта.

### Моментальное создание при изменении настроек

Когда пользователь в UI включает автопубликацию или обновляет конфигурацию объекта, система создает задачи сразу, не дожидаясь следующего ежедневного окна.  
Это позволяет публиковать в течение дня при наличии разрешенного времени и валидной конфигурации.

## Планирование времени публикаций

Для каждого аккаунта используется режим:

- safe;
- normal;
- aggressive;
- smart;
- fix.

Логика:

- задачи внутри аккаунта строятся в очередность по объектам и чатам;
- для большинства режимов применяется базовый интервал и случайный джиттер;
- в режиме smart задачи равномерно распределяются на рабочее окно;
- число задач ограничивается дневным лимитом аккаунта.

## Обработка задач воркером

Периодический воркер обработки аккаунтных очередей:

- запускается регулярно;
- выбирает активные аккаунты;
- считает публикации за текущий день;
- пропускает аккаунты с достигнутым лимитом;
- выбирает готовые задачи (`pending` с временем не позже текущего);
- переводит задачи в `processing`;
- проверяет актуальность конфигурации объекта;
- проверяет дубликаты;
- проверяет rate-limit;
- публикует через Telethon;
- фиксирует результат и историю.

## Защита и отказоустойчивость

### Soft/Hard time limits

Для задач Celery используются лимиты времени:

- мягкий лимит;
- жесткий лимит.

При срабатывании мягкого лимита запускается логика восстановления застрявших задач.

### Восстановление застрявших задач

Если задача находится в `processing` дольше порога:

- задача возвращается в `pending` для повторной попытки;
- счетчик попыток увеличивается;
- при достижении максимума попыток задача переводится в `failed`.

### FloodWait

При ограничениях Telegram:

- задача помечается как `flood_wait`;
- аккаунт деактивируется;
- фиксируется причина и длительность ожидания;
- требуется ручная реактивация аккаунта.

## Проверки консистентности перед отправкой

Перед фактической отправкой выполняются проверки:

- объект и чат существуют;
- автопубликация для объекта все еще включена;
- аккаунт и чат присутствуют в актуальной конфигурации;
- нет запрета по дубликатам;
- отсутствует активный rate-limit.

Если проверка не проходит, задача корректно помечается ошибкой и не уходит в Telegram.

## Почему задача может не уйти сразу

Типичные причины:

- задача создана с временем в будущем;
- аккаунт исчерпал дневной лимит;
- задача застряла в `processing` и блокирует операционный поток;
- текущая конфигурация объекта изменилась и задача стала невалидной;
- аккаунт получил `flood_wait`;
- временные ошибки Telethon/сети.

## Мониторинг и операционная диагностика

Для контроля используются диагностические скрипты:

- общий диагноз аккаунтной автопубликации;
- проверка готовности системы;
- сброс застрявших задач;
- статус по аккаунтам с очередями и ближайшими временами.

Операционно важно отслеживать:

- число задач по статусам;
- число задач, готовых к выполнению;
- застрявшие `processing`;
- публикации за текущий день по аккаунтам;
- состояние лимитов и последние ошибки аккаунтов.

## Результат для бизнеса

Подсистема обеспечивает предсказуемую и управляемую публикацию от аккаунтов:

- есть централизованная очередь;
- есть контроль лимитов и дубликатов;
- есть механизмы восстановления;
- есть инструменты прозрачной диагностики.

