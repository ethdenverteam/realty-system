# Техническое задание: Система автопубликации объектов недвижимости

## Версия: 1.0
## Дата: 2026-02-09

---

## 1. Общее описание

Система автопубликации позволяет пользователям автоматически публиковать объекты недвижимости в Telegram-чаты через бота и/или через свои Telegram-аккаунты по расписанию.

### 1.1. Основные принципы

- **Автопубликация всегда включает бота** (если автопубликация включена, бот всегда участвует)
- **Пользователь может дополнительно выбрать публикацию через свои Telegram-аккаунты**
- **Отдельные очереди для бота и для каждого Telegram-аккаунта**
- **Очередь работает с 9:00 до 21:00 МСК** (12 часов)
- **Интервалы публикации зависят от режима аккаунта** (normal: 2 мин, safe: 5 мин, aggressive: 1 мин)
- **Объекты добавляются в ближайшее свободное время** в очереди
- **При отключении автопубликации задачи удаляются, следующие задачи сдвигаются**

---

## 2. Доменные сущности

### 2.1. Объект недвижимости (`Object`)

**Таблица:** `objects`

**Ключевые поля:**
- `object_id` (String, PK) - уникальный идентификатор объекта
- `user_id` (Integer, FK) - владелец объекта
- `status` (String) - **ВАЖНО: только для автопубликации (вкл/выкл), никаких архивов и черновиков!**
- `rooms_type`, `price`, `districts_json`, `photos_json` - параметры объекта
- Контактные данные: `phone_number`, `show_username`, `contact_name`

**Связи:**
- Один-к-одному с `AutopublishConfig` (через `object_id`)

**Правила:**
- Если объект удалён → удаляются все связанные задачи автопубликации
- Статус объекта влияет только на автопубликацию (вкл/выкл), других статусов нет

---

### 2.2. Настройки автопубликации (`AutopublishConfig`)

**Таблица:** `autopublish_configs`

**Ключевые поля:**
- `config_id` (Integer, PK)
- `user_id` (Integer, FK) - владелец настроек
- `object_id` (String, FK) - объект, для которого настроена автопубликация
- `enabled` (Boolean) - **включена ли автопубликация** (переключатель вкл/выкл)
- `bot_enabled` (Boolean) - **всегда `True`, если `enabled=True`** (бот всегда включён при автопубликации)
- `accounts_config_json` (JSON) - конфигурация Telegram-аккаунтов и чатов:
  ```json
  {
    "accounts": [
      {
        "account_id": 1,
        "chat_ids": [10, 11, 12]
      },
      {
        "account_id": 2,
        "chat_ids": [20, 21]
      }
    ]
  }
  ```

**Правила:**
- Если `enabled=False` → автопубликация отключена, но настройки чатов сохраняются
- Если `enabled=True` → бот всегда включён (`bot_enabled=True`)
- Пользователь может включать/выключать публикацию через свои аккаунты через `accounts_config_json`

---

### 2.3. Telegram-аккаунт пользователя (`TelegramAccount`)

**Таблица:** `telegram_accounts`

**Ключевые поля:**
- `account_id` (Integer, PK)
- `owner_id` (Integer, FK) - владелец аккаунта (пользователь веб-интерфейса)
- `phone` (String) - номер телефона аккаунта
- `session_file` (String) - путь к файлу сессии Telethon
- `mode` (String) - **режим публикации: `normal` (2 мин), `safe` (5 мин), `aggressive` (1 мин)**
- `daily_limit` (Integer) - лимит публикаций в день
- `is_active` (Boolean) - активен ли аккаунт

**Правила:**
- Каждый аккаунт имеет **свою отдельную очередь** публикаций
- Интервал публикации определяется полем `mode`:
  - `normal` → каждые 2 минуты
  - `safe` → каждые 5 минут
  - `aggressive` → каждую минуту

---

### 2.4. Чат (`Chat`)

**Таблица:** `chats`

**Ключевые поля:**
- `chat_id` (Integer, PK)
- `telegram_chat_id` (String) - ID чата в Telegram
- `title` (String) - название чата
- `owner_type` (String) - `bot` или `user`
- `owner_account_id` (Integer, FK, nullable) - для `owner_type='user'`, ссылка на `TelegramAccount`
- `filters_json` (JSON) - фильтры для подбора объектов (тип комнат, районы, цена)
- `is_active` (Boolean) - активен ли чат

**Правила:**
- Бот-чаты (`owner_type='bot'`) подбираются автоматически по фильтрам объекта
- Чаты аккаунтов (`owner_type='user'`) выбираются пользователем в настройках автопубликации

---

### 2.5. Группа чатов (`ChatGroup`)

**Таблица:** `chat_groups`

**Ключевые поля:**
- `group_id` (Integer, PK)
- `user_id` (Integer, FK)
- `name` (String) - название группы (например, "однокомнатные")
- `chat_ids` (JSON) - массив `chat_id` из таблицы `chats`

**Правила:**
- Пользователь может создавать группы чатов для удобства выбора
- При добавлении группы к объекту в автопубликацию, все чаты из группы добавляются в `accounts_config_json`

---

### 2.6. Очередь публикаций (`PublicationQueue`)

**Таблица:** `publication_queues`

**Ключевые поля:**
- `queue_id` (Integer, PK)
- `object_id` (String, FK) - объект для публикации
- `chat_id` (Integer, FK) - чат, куда публикуем
- `account_id` (Integer, FK, nullable) - **NULL для бота, ID аккаунта для пользовательских публикаций**
- `user_id` (Integer, FK) - владелец объекта
- `type` (String) - `bot` или `user` (через что публикуем)
- `mode` (String) - `immediate` / `scheduled` / `autopublish`
- `status` (String) - `pending` / `processing` / `completed` / `failed` / `retrying`
- `scheduled_time` (DateTime) - **время публикации (должно быть между 9:00 и 21:00 МСК)**
- `started_at`, `completed_at` (DateTime)
- `attempts` (Integer) - количество попыток
- `error_message` (Text) - текст ошибки при неудаче
- `message_id` (String) - ID сообщения в Telegram
- `created_at` (DateTime)

**Правила:**
- **Одна очередь для бота:** все записи с `type='bot'`, `account_id=NULL`
- **Отдельные очереди для каждого аккаунта:** все записи с `type='user'`, `account_id=X`
- `scheduled_time` должен быть в диапазоне 9:00-21:00 МСК
- При отключении автопубликации задачи удаляются, следующие задачи сдвигаются на освободившееся время

---

### 2.7. История публикаций (`PublicationHistory`)

**Таблица:** `publication_history`

**Ключевые поля:**
- `history_id` (Integer, PK)
- `queue_id` (Integer, FK) - ссылка на задачу
- `object_id` (String, FK)
- `chat_id` (Integer, FK)
- `account_id` (Integer, FK, nullable)
- `published_at` (DateTime) - время публикации
- `message_id` (String) - ID сообщения в Telegram
- `deleted` (Boolean) - удалено ли сообщение

**Правила:**
- Используется для проверки: **не публиковать один объект в один чат чаще, чем раз в 24 часа**

---

## 3. Логика работы автопубликации

### 3.1. Настройка автопубликации пользователем

#### 3.1.1. Интерфейс меню автопубликации

Пользователь видит:
- **Список всех объектов** с настройками автопубликации:
  - Переключатель "Автопубликация вкл/выкл" (`enabled`)
  - Переключатель "Публикация через аккаунты вкл/выкл" (через `accounts_config_json`)
  - Список выбранных пользовательских чатов (из `accounts_config_json`)
  - Возможность добавить/удалить чаты или группы чатов
- **Список объектов, которые ещё не в автопубликации** (для добавления)

#### 3.1.2. Сохранение настроек

**Эндпоинт:** `POST /dashboard/autopublish` или `PUT /dashboard/autopublish/<object_id>`

**Логика:**
1. Создаётся/обновляется `AutopublishConfig`:
   - Если `enabled=True` → `bot_enabled=True` (автоматически)
   - Сохраняется `accounts_config_json` с выбранными аккаунтами и чатами
2. Если `enabled=True`:
   - Объект добавляется в **общую очередь бота** (синхронизация с базой бота)
   - Создаются задачи в `PublicationQueue` для бота и для каждого аккаунта
3. Если `enabled=False`:
   - Удаляются все будущие задачи (`status='pending'` или `status='scheduled'`) для этого объекта
   - Следующие задачи в очереди **сдвигаются на освободившееся время**

---

### 3.2. Структура очередей

#### 3.2.1. Очередь бота

**Идентификация:** `type='bot'`, `account_id=NULL`

**Источник задач:**
- Все объекты с `AutopublishConfig.enabled=True`, `bot_enabled=True`
- Чаты подбираются автоматически по фильтрам объекта (через `_get_matching_bot_chats_for_object`)

**Правила:**
- Одна общая очередь для всех бот-чатов
- Время публикации: `scheduled_time` между 9:00 и 21:00 МСК
- Объекты добавляются в **ближайшее свободное время**

#### 3.2.2. Очередь для каждого Telegram-аккаунта

**Идентификация:** `type='user'`, `account_id=X` (где X - ID аккаунта)

**Источник задач:**
- Все объекты с `AutopublishConfig.enabled=True` и `accounts_config_json`, содержащим этот `account_id`
- Чаты берутся из `accounts_config_json[account_id].chat_ids`

**Правила:**
- **Отдельная очередь для каждого аккаунта**
- Интервал публикации определяется `TelegramAccount.mode`:
  - `normal` → каждые 2 минуты
  - `safe` → каждые 5 минут
  - `aggressive` → каждую минуту
- Время публикации: `scheduled_time` между 9:00 и 21:00 МСК
- Объекты добавляются в **ближайшее свободное время** с учётом интервала аккаунта

**Пример:**
- Если выбрано 10 чатов для каждого из 5 объектов → создаётся **50 заданий** в очереди этого аккаунта

---

### 3.3. Добавление объекта в очередь

#### 3.3.1. Когда объект добавляется в очередь

**Сценарий 1: Пользователь только что включил автопубликацию**
- Если сейчас **до 9:00 МСК** → первая публикация **сегодня в 9:00**
- Если сейчас **после 9:00 МСК** → первая публикация **завтра в 9:00** (или в ближайшее свободное время)

**Сценарий 2: Ежедневное расписание**
- Ежедневно в 9:00 МСК запускается задача `schedule_daily_autopublish`
- Создаются задачи на текущий день для всех включённых объектов

**Сценарий 3: После публикации**
- После попытки публикации (успешной или нет) объект добавляется в очередь следующего дня

#### 3.3.2. Алгоритм добавления в очередь

**Для очереди бота:**
1. Определяем ближайшее свободное время (начиная с 9:00 МСК текущего или следующего дня)
2. Проверяем, нет ли уже задачи на это время для этого объекта в этой очереди
3. Если время занято → ищем следующее свободное время
4. Создаём `PublicationQueue` с `scheduled_time = найденное_время`

**Для очереди аккаунта:**
1. Определяем ближайшее свободное время с учётом интервала аккаунта:
   - Если последняя публикация была в `T`, следующая может быть в `T + interval`
2. Проверяем, нет ли уже задачи на это время для этого объекта в этой очереди аккаунта
3. Если время занято → ищем следующее свободное время с учётом интервала
4. Создаём `PublicationQueue` с `scheduled_time = найденное_время`

**Вопросы для уточнения:**
- Как именно определяется "свободное время"? Проверяем только `scheduled_time` или учитываем также время выполнения задач (`started_at`, `completed_at`)?
- Если очередь заполнена до 21:00, куда добавляем новые объекты? На следующий день с 9:00?

---

### 3.4. Обработка очереди

#### 3.4.1. Задача Celery: обработка очереди бота

**Название:** `process_bot_autopublish_queue`

**Расписание:** каждую минуту

**Логика:**
1. Берём все `PublicationQueue` с:
   - `type='bot'`
   - `account_id=NULL`
   - `mode='autopublish'`
   - `status='pending'`
   - `scheduled_time <= now()`
2. Сортируем по `scheduled_time` (старейшие первыми)
3. Для каждой задачи:
   - Проверяем правило "не чаще раза в сутки" (через `PublicationHistory`)
   - Если можно публиковать → вызываем `publish_to_telegram_bot(queue_id)`
   - Если нельзя → пропускаем, создаём задачу на следующий день

#### 3.4.2. Задача Celery: обработка очереди аккаунта

**Название:** `process_account_autopublish_queue(account_id)`

**Расписание:** каждую минуту для каждого активного аккаунта

**Логика:**
1. Берём все `PublicationQueue` с:
   - `type='user'`
   - `account_id=account_id`
   - `mode='autopublish'`
   - `status='pending'`
   - `scheduled_time <= now()`
2. Сортируем по `scheduled_time` (старейшие первыми)
3. Для каждой задачи:
   - Проверяем правило "не чаще раза в сутки"
   - Проверяем `daily_limit` аккаунта
   - Если можно публиковать → вызываем `publish_to_telegram_account(queue_id)`
   - Если нельзя → пропускаем, создаём задачу на следующий день

#### 3.4.3. Задача Celery: ежедневное создание задач

**Название:** `schedule_daily_autopublish`

**Расписание:** ежедневно в 9:00 МСК (06:00 UTC)

**Логика:**
1. Берём все `AutopublishConfig` с `enabled=True`
2. Для каждого конфига:
   - Проверяем, что объект существует и не удалён
   - Если `bot_enabled=True`:
     - Подбираем подходящие бот-чаты
     - Для каждого чата создаём задачу в очереди бота на текущий день
   - Если есть `accounts_config_json`:
     - Для каждого аккаунта в конфиге:
       - Берём чаты из `chat_ids`
       - Для каждого чата создаём задачу в очереди этого аккаунта на текущий день

**Вопросы для уточнения:**
- Нужно ли создавать задачи на весь день сразу (9:00, 9:02, 9:04, ...) или только на ближайшее время?
- Как обрабатывать случаи, когда очередь уже заполнена?

---

### 3.5. Публикация объекта

#### 3.5.1. Публикация через бота

**Функция:** `publish_to_telegram_bot(queue_id)`

**Логика:**
1. Берём `PublicationQueue` по `queue_id`
2. Проверяем, что `type='bot'`, `account_id=NULL`
3. Получаем объект и чат
4. Проверяем правило "не чаще раза в сутки" (через `PublicationHistory`)
5. Форматируем текст публикации
6. Отправляем через Bot API (`sendMessage` или `sendMediaGroup`)
7. При успехе:
   - Обновляем `status='completed'`
   - Создаём `PublicationHistory`
   - Обновляем статистику чата
   - **Создаём задачу на следующий день** (в ближайшее свободное время)
8. При ошибке:
   - Обновляем `status='failed'`
   - Сохраняем `error_message`
   - **Всё равно создаём задачу на следующий день** (в ближайшее свободное время)

#### 3.5.2. Публикация через аккаунт пользователя

**Функция:** `publish_to_telegram_account(queue_id)`

**Логика:**
1. Берём `PublicationQueue` по `queue_id`
2. Проверяем, что `type='user'`, `account_id` указан
3. Получаем объект, чат и аккаунт
4. Проверяем правило "не чаще раза в сутки"
5. Проверяем `daily_limit` аккаунта
6. Форматируем текст публикации
7. Отправляем через Telethon (клиент аккаунта)
8. При успехе:
   - Обновляем `status='completed'`
   - Создаём `PublicationHistory`
   - Обновляем статистику чата и аккаунта
   - **Создаём задачу на следующий день** (в ближайшее свободное время с учётом интервала)
9. При ошибке:
   - Обновляем `status='failed'`
   - Сохраняем `error_message`
   - **Всё равно создаём задачу на следующий день** (в ближайшее свободное время с учётом интервала)

---

### 3.6. Отключение автопубликации

#### 3.6.1. Выключение автопубликации для объекта

**Действия:**
1. Устанавливаем `AutopublishConfig.enabled=False` (настройки чатов сохраняются)
2. Удаляем все будущие задачи (`status='pending'` или `status='scheduled'`) для этого объекта:
   - Из очереди бота (`type='bot'`, `account_id=NULL`)
   - Из очередей всех аккаунтов (`type='user'`, `account_id=X`)
3. **Сдвигаем следующие задачи на освободившееся время:**
   - Для очереди бота: пересчитываем `scheduled_time` для всех задач после удалённых
   - Для очередей аккаунтов: пересчитываем `scheduled_time` с учётом интервала аккаунта

**Вопросы для уточнения:**
- Как именно происходит "сдвиг"? Пересчитываем все `scheduled_time` для задач после удалённых или только ближайшие?
- Нужно ли учитывать интервалы при сдвиге (например, если удалили задачу на 10:00, а следующая была на 10:05, сдвигаем ли её на 10:00 или оставляем 10:05)?

#### 3.6.2. Удаление объекта из общей очереди бота

**Действия:**
1. Удаляем объект из базы бота (или помечаем как неактивный)
2. Удаляем все будущие задачи для этого объекта в очереди бота
3. **Сдвигаем следующие задачи на освободившееся время**

---

### 3.7. Правило "не чаще раза в сутки"

**Проверка перед публикацией:**
1. Берём `PublicationHistory` для пары (объект, чат)
2. Проверяем, есть ли публикация за последние 24 часа (`published_at >= now() - 24 hours`, `deleted=False`)
3. Если есть → пропускаем публикацию, создаём задачу на следующий день
4. Если нет → публикуем

**Применяется:**
- Для публикаций через бота
- Для публикаций через аккаунты пользователей

---

## 4. Текущая реализация и проблемы

### 4.1. Что уже реализовано

- ✅ Модели: `AutopublishConfig`, `PublicationQueue`, `Chat`, `ChatGroup`, `TelegramAccount`
- ✅ Роуты для настройки автопубликации (`/dashboard/autopublish`)
- ✅ Базовая логика создания задач в `PublicationQueue`
- ✅ Задача `schedule_daily_autopublish` (запускается в 9:00 МСК)
- ✅ Задача `process_autopublish` (обрабатывает очередь каждую минуту)
- ✅ Функция `publish_to_telegram` (публикует через Bot API)

### 4.2. Основные проблемы

#### 4.2.1. Нет разделения очередей

**Проблема:**
- Сейчас все задачи хранятся в одной таблице `PublicationQueue`
- Нет явного разделения на "очередь бота" и "очереди аккаунтов"
- Не учитываются интервалы аккаунтов при планировании

**Решение:**
- Использовать фильтрацию по `type` и `account_id` для разделения очередей
- При создании задач учитывать `TelegramAccount.mode` для расчёта интервалов

#### 4.2.2. Не учитывается время 9:00-21:00 МСК

**Проблема:**
- `scheduled_time` не ограничен диапазоном 9:00-21:00 МСК
- Задачи могут создаваться на любое время

**Решение:**
- При создании задач проверять, что `scheduled_time` в диапазоне 9:00-21:00 МСК
- Если время выходит за пределы → переносить на следующий день с 9:00

#### 4.2.3. Не реализована публикация через аккаунты пользователей

**Проблема:**
- `publish_to_telegram` всегда использует Bot API
- Не учитывается `type='user'` и `account_id`
- Нет интеграции с Telethon для публикации через аккаунты

**Решение:**
- Создать отдельную функцию `publish_to_telegram_account` с использованием Telethon
- Использовать `app.utils.telethon_client` для работы с аккаунтами

#### 4.2.4. Не реализован сдвиг задач при отключении

**Проблема:**
- При отключении автопубликации задачи удаляются, но следующие задачи не сдвигаются
- В очереди остаются "дыры" во времени

**Решение:**
- При удалении задач пересчитывать `scheduled_time` для всех последующих задач
- Учитывать интервалы аккаунтов при сдвиге

#### 4.2.5. Не учитываются интервалы аккаунтов

**Проблема:**
- При создании задач не учитывается `TelegramAccount.mode`
- Все задачи создаются без учёта интервалов (2 мин, 5 мин, 1 мин)

**Решение:**
- При создании задач для аккаунта учитывать `mode`:
  - `normal` → интервал 2 минуты
  - `safe` → интервал 5 минут
  - `aggressive` → интервал 1 минута
- При расчёте "ближайшего свободного времени" учитывать интервал

#### 4.2.6. При ошибке не создаётся задача на следующий день

**Проблема:**
- В текущей реализации задача на следующий день создаётся только при успешной публикации
- При ошибке объект не планируется на следующий день

**Решение:**
- Создавать задачу на следующий день **всегда** (и при успехе, и при ошибке)
- Сохранять информацию об ошибке в `error_message` для мониторинга

---

## 5. План рефакторинга

### 5.1. Этап 1: Уточнение структуры данных

**Задачи:**
- [ ] Уточнить логику определения "свободного времени" в очереди
- [ ] Уточнить алгоритм сдвига задач при отключении автопубликации
- [ ] Уточнить поведение при заполнении очереди до 21:00

### 5.2. Этап 2: Рефакторинг создания задач

**Задачи:**
- [ ] Обновить `schedule_daily_autopublish` для учёта интервалов аккаунтов
- [ ] Обновить логику добавления объекта в очередь (учёт 9:00-21:00 МСК)
- [ ] Реализовать функцию поиска ближайшего свободного времени с учётом интервалов

### 5.3. Этап 3: Реализация публикации через аккаунты

**Задачи:**
- [ ] Создать функцию `publish_to_telegram_account` с использованием Telethon
- [ ] Обновить `process_autopublish` для разделения обработки очереди бота и очередей аккаунтов
- [ ] Добавить проверку `daily_limit` аккаунта

### 5.4. Этап 4: Реализация сдвига задач

**Задачи:**
- [ ] Реализовать функцию сдвига задач при отключении автопубликации
- [ ] Реализовать функцию сдвига задач при удалении объекта из очереди бота
- [ ] Учесть интервалы аккаунтов при сдвиге

### 5.5. Этап 5: Обновление роутов

**Задачи:**
- [ ] Обновить `POST /dashboard/autopublish` для правильного создания задач
- [ ] Обновить `PUT /dashboard/autopublish/<object_id>` для правильного обновления задач
- [ ] Обновить `DELETE /dashboard/autopublish/<object_id>` для удаления задач и сдвига

### 5.6. Этап 6: Тестирование

**Задачи:**
- [ ] Протестировать создание задач в очередь бота
- [ ] Протестировать создание задач в очереди аккаунтов с разными интервалами
- [ ] Протестировать публикацию через бота и через аккаунты
- [ ] Протестировать сдвиг задач при отключении автопубликации
- [ ] Протестировать правило "не чаще раза в сутки"

---

## 6. Вопросы для уточнения

### 6.1. Логика очереди

1. **Как определяется "свободное время"?**
   - Проверяем только `scheduled_time` или учитываем также `started_at` / `completed_at`?
   - Если задача в статусе `processing`, считается ли это время занятым?

2. **Что делать, если очередь заполнена до 21:00?**
   - Добавлять объекты на следующий день с 9:00?
   - Или расширять время работы очереди?

3. **Как работает сдвиг задач при отключении?**
   - Пересчитываем все `scheduled_time` для задач после удалённых?
   - Или только ближайшие задачи?
   - Учитываем ли интервалы при сдвиге (например, если удалили задачу на 10:00, а следующая была на 10:05, сдвигаем ли её на 10:00 или оставляем 10:05)?

### 6.2. Ежедневное расписание

4. **Нужно ли создавать задачи на весь день сразу?**
   - Или только на ближайшее время (например, на ближайшие 2 часа)?

5. **Как обрабатывать случаи, когда очередь уже заполнена?**
   - Пропускать объект на этот день?
   - Или добавлять в конец очереди (после 21:00)?

### 6.3. Интервалы аккаунтов

6. **Как интервал применяется к очереди аккаунта?**
   - Если последняя публикация была в 10:00, следующая может быть в 10:02 (для `normal`)?
   - Или интервал применяется только к последовательным публикациям одного объекта?

7. **Можно ли публиковать разные объекты в один чат с интервалом меньше интервала аккаунта?**
   - Например, объект A в чат 1 в 10:00, объект B в чат 1 в 10:01 (для `normal`)?

---

## 7. Заключение

Данное техническое задание описывает целевую логику работы системы автопубликации и текущие проблемы реализации. После уточнения вопросов из раздела 6 будет создан финальный план рефакторинга с конкретными шагами реализации.

